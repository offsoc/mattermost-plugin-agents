// Copyright (c) 2023-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

package main

import (
	"context"
	"fmt"
	"net/http"
	"os"
	"time"

	"github.com/mattermost/mattermost-plugin-ai/api"
	"github.com/mattermost/mattermost-plugin-ai/bots"
	"github.com/mattermost/mattermost-plugin-ai/config"
	"github.com/mattermost/mattermost-plugin-ai/conversations"
	"github.com/mattermost/mattermost-plugin-ai/database"
	"github.com/mattermost/mattermost-plugin-ai/enterprise"
	"github.com/mattermost/mattermost-plugin-ai/i18n"
	"github.com/mattermost/mattermost-plugin-ai/indexer"
	"github.com/mattermost/mattermost-plugin-ai/llm"
	"github.com/mattermost/mattermost-plugin-ai/llmcontext"
	"github.com/mattermost/mattermost-plugin-ai/mcp"
	"github.com/mattermost/mattermost-plugin-ai/meetings"
	"github.com/mattermost/mattermost-plugin-ai/metrics"
	"github.com/mattermost/mattermost-plugin-ai/mmapi"
	"github.com/mattermost/mattermost-plugin-ai/mmtools"
	"github.com/mattermost/mattermost-plugin-ai/prompts"
	"github.com/mattermost/mattermost-plugin-ai/search"
	"github.com/mattermost/mattermost-plugin-ai/streaming"
	"github.com/mattermost/mattermost/server/public/model"
	"github.com/mattermost/mattermost/server/public/plugin"
	"github.com/mattermost/mattermost/server/public/pluginapi"
	"github.com/mattermost/mattermost/server/public/shared/httpservice"
)

func main() {
	plugin.ClientMain(&Plugin{})
}

type Plugin struct {
	plugin.MattermostPlugin

	configuration config.Container

	pluginAPI            *pluginapi.Client
	apiService           *api.API
	bots                 *bots.MMBots
	indexerService       *indexer.Indexer
	conversationsService *conversations.Conversations
	mcpClientManager     *mcp.ClientManager
}

func (p *Plugin) OnActivate() error {
	pluginAPI := pluginapi.NewClient(p.API, p.Driver)
	mmClient := mmapi.NewClient(pluginAPI)
	licenseChecker := enterprise.NewLicenseChecker(pluginAPI)
	dbClient := mmapi.NewDBClient(pluginAPI)

	i18nBundle := i18n.Init()

	llmUpstreamHTTPClient := httpservice.MakeHTTPServicePlugin(p.API).MakeClient(true)
	llmUpstreamHTTPClient.Timeout = time.Minute * 10 // LLM requests can be slow

	untrustedHTTPClient := httpservice.MakeHTTPServicePlugin(p.API).MakeClient(false)

	metricsService := metrics.NewMetrics(metrics.InstanceInfo{
		InstallationID: os.Getenv("MM_CLOUD_INSTALLATION_ID"),
		PluginVersion:  manifest.Version, // Manifest imported from manifest.go which is generated by the build process
	})

	potentiallyUpdatedConfig, wasUpdated, err := runAllMigrations(p.API, pluginAPI, &p.configuration)
	if err != nil {
		return fmt.Errorf("failed to run migrations: %w", err)
	}
	if wasUpdated {
		// Update in-memory copy immediately (can't wait for async callbacks)
		p.configuration.Update(&potentiallyUpdatedConfig)
		pluginAPI.Log.Info("In-memory configuration updated after migrations")
	}

	tokenLogger, err := llm.CreateTokenLogger()
	if err != nil {
		return fmt.Errorf("failed to create token usage logger: %w", err)
	}

	bots := bots.New(p.API, pluginAPI, licenseChecker, &p.configuration, llmUpstreamHTTPClient, tokenLogger)
	p.configuration.RegisterUpdateListener(func() {
		if ensureErr := bots.EnsureBots(); ensureErr != nil {
			pluginAPI.Log.Error("failed to ensure bots on configuration update", "error", ensureErr)
			return
		}
	})

	if ensureBotsErr := bots.EnsureBots(); ensureBotsErr != nil {
		// If we fail to ensure bots, we log the error but do not return
		// as it would leave the plugin in a state where it can't be configured from the system console.
		pluginAPI.Log.Error("failed to ensure bots", "error", ensureBotsErr)
	}

	if setupTablesErr := database.SetupTables(dbClient.DB); setupTablesErr != nil {
		pluginAPI.Log.Error("failed to setup database tables", "error", setupTablesErr)
		return setupTablesErr
	}

	prompts, promptManagerErr := llm.NewPrompts(prompts.PromptsFolder)
	if promptManagerErr != nil {
		pluginAPI.Log.Error("failed to initialize prompts", "error", promptManagerErr)
		return promptManagerErr
	}

	streamingService := streaming.NewMMPostStreamService(mmClient, i18nBundle)

	embeddingsSearch, err := search.InitEmbeddingsSearch(
		dbClient.DB,
		llmUpstreamHTTPClient,
		p.configuration.EmbeddingSearchConfig(),
		licenseChecker,
	)
	if err != nil {
		pluginAPI.Log.Error("failed to initialize search infrastructure", "error", err)
		// Continue without search functionality
	}

	indexerService := indexer.New(embeddingsSearch, mmClient, bots, dbClient.DB)

	searchService := search.New(
		embeddingsSearch,
		mmClient,
		prompts,
		streamingService,
		licenseChecker,
	)

	toolProvider := mmtools.NewMMToolProvider(
		mmClient,
		searchService,
		untrustedHTTPClient,
	)

	// Build redirect URI
	siteURL := pluginAPI.Configuration.GetConfig().ServiceSettings.SiteURL
	if siteURL == nil || *siteURL == "" {
		return fmt.Errorf("site URL not configured")
	}
	manifestID := manifest.Id
	oauthCallbackURL := fmt.Sprintf("%s/plugins/%s/oauth/callback", *siteURL, manifestID)

	// Create embedded MCP server if enabled
	var embeddedMCPServer mcp.EmbeddedMCPServer
	if p.configuration.MCP().EmbeddedServer.Enabled {
		var err error
		embeddedMCPServer, err = NewEmbeddedMCPServer(pluginAPI, pluginAPI.Log)
		if err != nil {
			pluginAPI.Log.Error("Failed to create embedded MCP server", "error", err)
			// Continue without embedded server
		} else {
			pluginAPI.Log.Info("Embedded MCP server created successfully")
		}
	}

	mcpClientManager := mcp.NewClientManager(p.configuration.MCP(), pluginAPI.Log, pluginAPI, mcp.NewOAuthManager(mmClient, oauthCallbackURL), embeddedMCPServer)
	p.configuration.RegisterUpdateListener(func() {
		var embeddedServer mcp.EmbeddedMCPServer
		if p.configuration.MCP().EmbeddedServer.Enabled {
			var err error
			embeddedServer, err = NewEmbeddedMCPServer(pluginAPI, pluginAPI.Log)
			if err != nil {
				pluginAPI.Log.Error("Failed to create embedded MCP server on config update", "error", err)
			}
		}

		mcpClientManager.ReInit(p.configuration.MCP(), embeddedServer)
	})

	contextBuilder := llmcontext.NewLLMContextBuilder(
		pluginAPI,
		toolProvider,
		mcpClientManager,
		&p.configuration,
	)

	conversationsService := conversations.New(
		prompts,
		mmClient,
		streamingService,
		contextBuilder,
		bots,
		dbClient,
		licenseChecker,
		i18nBundle,
		nil, // meetingsService will be set after it's created
	)

	meetingsService := meetings.NewService(
		pluginAPI,
		streamingService,
		prompts,
		bots,
		i18nBundle,
		metricsService,
		dbClient,
		contextBuilder,
		conversationsService,
	)

	// Set the meetings service on conversations to break circular dependency
	// TODO: Refactor to avoid circular dependency
	conversationsService.SetMeetingsService(meetingsService)

	apiService := api.New(
		bots,
		conversationsService,
		meetingsService,
		indexerService,
		searchService,
		pluginAPI,
		metricsService,
		contextBuilder,
		&p.configuration,
		prompts,
		mmClient,
		dbClient,
		licenseChecker,
		streamingService,
		i18nBundle,
		mcpClientManager,
	)

	// Keep only what we need
	p.pluginAPI = pluginAPI
	p.apiService = apiService
	p.bots = bots
	p.indexerService = indexerService
	p.conversationsService = conversationsService
	p.mcpClientManager = mcpClientManager

	return nil
}

func (p *Plugin) OnDeactivate() error {
	// Clean up MCP client manager if it exists
	p.mcpClientManager.Close()

	return nil
}

func (p *Plugin) MessageHasBeenPosted(c *plugin.Context, post *model.Post) {
	// Index the new message in the vector database
	if p.indexerService != nil {
		// Get channel to retrieve team ID
		channel, err := p.API.GetChannel(post.ChannelId)
		if err != nil {
			p.pluginAPI.Log.Error("Failed to get channel for post indexing", "error", err)
		} else {
			if err := p.indexerService.IndexPost(context.Background(), post, channel); err != nil {
				p.pluginAPI.Log.Error("Failed to index post in vector database", "error", err)
			}
		}
	}

	p.conversationsService.MessageHasBeenPosted(c, post)
}

func (p *Plugin) MessageHasBeenUpdated(c *plugin.Context, newPost, oldPost *model.Post) {
	// Handle indexing of updated posts
	if p.indexerService != nil {
		// Delete the old post from index
		if err := p.indexerService.DeletePost(context.Background(), oldPost.Id); err != nil {
			p.pluginAPI.Log.Error("Failed to delete post from vector database", "error", err)
		}

		// Get channel to retrieve team ID
		channel, err := p.API.GetChannel(newPost.ChannelId)
		if err != nil {
			p.pluginAPI.Log.Error("Failed to get channel for post indexing", "error", err)
		} else {
			// Index the updated post
			if err := p.indexerService.IndexPost(context.Background(), newPost, channel); err != nil {
				p.pluginAPI.Log.Error("Failed to index updated post in vector database", "error", err)
			}
		}
	}
}

func (p *Plugin) MessageHasBeenDeleted(c *plugin.Context, post *model.Post) {
	if p.indexerService != nil {
		if err := p.indexerService.DeletePost(context.Background(), post.Id); err != nil {
			p.pluginAPI.Log.Error("Failed to delete post from vector database", "error", err)
		}
	}
}

func (p *Plugin) ServeHTTP(c *plugin.Context, w http.ResponseWriter, r *http.Request) {
	p.apiService.ServeHTTP(c, w, r)
}

func (p *Plugin) ServeMetrics(c *plugin.Context, w http.ResponseWriter, r *http.Request) {
	p.apiService.ServeMetrics(c, w, r)
}

// EmailNotificationWillBeSent blocks email notifications for bot replies in threads.
func (p *Plugin) EmailNotificationWillBeSent(emailNotification *model.EmailNotification) (*model.EmailNotificationContent, string) {
	if p.shouldBlockBotReplyNotification(emailNotification.SenderId, emailNotification.RootId) {
		return nil, "notification blocked: bot reply in thread"
	}
	return &emailNotification.EmailNotificationContent, ""
}

// NotificationWillBePushed blocks push notifications for bot replies in threads.
// IMPORTANT: This hook must execute quickly as it can become blocking and delay post creation.
func (p *Plugin) NotificationWillBePushed(pushNotification *model.PushNotification, userID string) (*model.PushNotification, string) {
	if pushNotification.PostId == "" {
		return pushNotification, ""
	}

	if p.shouldBlockBotReplyNotification(pushNotification.SenderId, pushNotification.RootId) {
		return nil, "notification blocked: bot reply in thread"
	}
	return pushNotification, ""
}

func (p *Plugin) shouldBlockBotReplyNotification(senderID, rootID string) bool {
	// Only check threaded replies
	if rootID == "" {
		return false
	}

	// Check if bots service is initialized
	if p.bots == nil {
		return false
	}

	// Check if sender is a bot by looking up in the bots cache
	bot := p.bots.GetBotByID(senderID)
	if bot == nil {
		return false
	}

	// Block all bot reply notifications in threads
	return true
}
